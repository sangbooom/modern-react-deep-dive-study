# 서버 사이드 렌더링

## 서버 사이드 렌더링이란?

### 4.1.1 싱플 페이지 어플리케이션의 세상
1. SPA란? 렌더링과 라우팅에 필요한 기능을 브라우저의 자바스크립트에 의존
2. 코드를 보면 비어있다. script로 모든 걸 제어. 이 script의 api를 이용해 페이지들을 그린다
3. 리소스가 커지지만 fetch를 제외 돔을 그리는데 UI/UX적으로 훌룡하다
4. 전통적인 방식. 페이지가 이동할 때마다 HTML을 새로 그림. 빈 화면 노출
5. 자바스크립트 모듈화: CommonJS, AMD -> AMD는 잘모름. Require.js. SPA 시대. 브라우저 내부의 자사스크립트만 신경 쓴다
6. JAM 스택. 빌드 후 제공. MERN 스택
7. 자바스크립트 사이즈가 커진다. -> CPU 소모 크고, TTI가 길다.  

### 4.1.2 서버 사이드 렌더링이란?
1. 최초 보여질 페이지만 서버에서 렌더링한다. 서버가 렌더링에 필요한 작업을 한다. -> 서버의 영향을 많이 받는다.
2. 장점
   1. 최초 페이지 진입이 빠르다. ( FCP )
      HTTP 요청도 서버가 빠르고, HTML 렌더링 하는 것도 서버가 빠르다. 페이지가 HTTP 요청에 의존적이라면 더 의미 있음
   2. 검색 엔진, 메타데이터 제공 ( SEO )
      검색엔진은 자바스크립트를 실행하지 않음. 정적인 정보를 가져옴. -> 빈 껍데기만 보고 나감. SSR은 처음부터 정적인 데이터 가득 
   3. 누적 레이아웃 이동이 적다 ( CLS )
      레이아웃 밀리는 걸 막음. 미리 그리니깐. 완벽하진 않음 -> React 18의 Stream
   4. 사용자의 디바이스 성능에 자유롭다. 
      서버 성능이 중요함. 근데 서버가 느리면 답 없다.
   5. 보안 에 안전
      브라우저에 노출하지 않고 서버에서 노출한다. -> 크게 도움 받은게 있었나? 인증도 localStorage로... 
3. 단점
   1. 소스코드를 작성할 때 서버 고려 -> RSC 분리되면서 편해졌다. 
   2. 적절한 서버 구축 -> Next 쓴다. 근데 요청 몰리면 답없다. PM2 돈 든다. 메모리 많이 쓴다. 미리 늘리는 수밖에? (as is) 
   3. 서비스 지연에 따른 UI. -> 이럴때 어떻게 했지? 그냥 기다렸나?

### 4.1.3 SPA와 SSR을 모두 알아야하는 이유
1. SSR이 만능은 아님. 같이 알아야함. -> 브라우저의 기능이 필요한 경우 같이 써야하니깐?
2. SPA vs SSR
   1. SPA가 완벽하면 SPA가 더 낫다. code spliting. helmet( Gmail은 필요 없으니 ), backoffice는 React로 
   2. 평균적으로는 SSR이 낫다. 라우팅 문제 해결 기법.
      1. 페이늩 홀딩 -> 흰 화면 대신 기존 페이지를 노출 하는 건가? 깜빡 없애서 좋을 것 같다.
      2. BFCache -> Next는 이 옵션 끄고 자체 Router 제공 한다 했나?
      3. transition ( 상범님이 한거 )
3. 현대의 SSR은 CSR의 장점 + SSR의 장점. LAMP는 빌드 시 페이지를 모두 굽는다. 근데 왜 라우팅이 일어날 때 새로 서버에서 주지? 그럼 굽질 말지? 

## 4.2 서버 사이드 렌더링을 위한 리액트 API 알아보기

### 4.2.1 renderToString
리액트 컴포넌트를 렌더링해 HTML 문자열로 반환해준다. 중요한건 JSX 부분만 변환한다. 자바스크립트 코드는 별도 브라우저에서, hydrate 단계에서 실행

### 4.2.2 renderToStaticMarkUp
renderToString와 달리 순수 HTML만 변환. 이 때 React 코드는 실행할 수 없다. 즉, hydrate 불가. 정적인 페이지를 구현할 때

### 4.2.3 renderToNodeStream
브라우저에서 실행 불가능. 문자열이 아닌 ReadableStream. React 18 Stream 방식에 사용되겠다.
크기가 너무 크면 청크 단위로 분리해 순차적으로 처리가 가능하다. ( 쓸모 없는 줄 알았는데 동시성 문제를 해결해주나? ) 

### 4.2.4 renderToStaticNodeStream
renderToNodeStream에서 hydrate되지 않는../

### 4.2.5 hydrate
HTML 콘텐츠에 JS 코드 붙이는 역할
render와의 차이점은 기본적으로 렌더린된 HTML이 있다는 가정하에 작업이 수행되고 그 기준에서 이벤트 핸들러만 붙인다.

#### 만약 준비된 HTML이 없다면 어떻게 될까?
1. Warning 하지만 정상적으로 웹 페이지를 만든다. [화해 블로그 글 Hydrate Miss Match](https://blog.hwahae.co.kr/all/tech/13604)
2. JS 코드를 붙이면서 HTML을 한 번 렌더링 후 인수로 받은 HTML 과 비교한다. -> 서버 클라이언트 2번 렌더링 하는 셈
3. 


#### render

```ts
const rootElement = document.getElementById('root');

React.DOM.render(<App />, rootElement)

// 1. div Element 생성
// 2. rootElement 자식에 붙이고
// 3. props 붙이는 작업

```

## 4.3 Next.js 톺아보기

### 4.3.2 Next.js 시작하기
1. next.config.js. 타입의 도움을 받을 수 있다. ( 이런 의미가.... ) 
   ```js
   // 타입의 도움을 받을 수 있다. ( 이런 의미가.... ) 
   /** @type {import('next').NextConfig}  **/
   
   // 엄격 모드
   reactStrictMode: true,
   
   // swc 빌드 최적화 하기
   swcMinify: true
   ```

2. page 디렉토리
   1. _app.tsx: entry file?. 공통 비즈니스 로직들을 담는다. 로그 찍으면 최초엔 서버 터미널에, 뒤엔 크롬 터미널에
   2. _document.tsx
      1. 애플리케이션 HTML 초기화. 필요한 HTMl들 넣기. `<Html lang='ko'>`
      2. 무조건 서버에서 실행
3. RSC [Dynamic Route](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes). 다양한 방법들 -> `[[...slug]]` -> 사이트 터졌었던..
4. `<a>`태그. 이동 시 모든 리소스 다시 다운로드. 서버에서 렌더링 후 클라이언트 hydrate  
   `<Link>` 클라이언트처럼 라우팅 
5. GSSP -> RSC. 
   GSSP를 제거한다면? -> CSR처럼 작동한다. 정적으로 페이지 생성.
   RSC에서 본다면? 빌드 시 굽는 과정일 때. 아직도 좀 헷갈리는데 정적 라우팅 + 동적 함수 사용 안하는 경우. 
   어떤 경우는 SSG로 표시되어도 해제되는 경우가 있음.
6. Route Handling. BFF 혹은 백엔드. -> KR에서 사용. 비용 문제.. 트래킹 문제..

### 4.3.3 Data Fetching
1. GetStaticPaths, GetStaticProps -> GenerateStaticParams
   1. fallback true. 만약 추가로 생성이 되었다. 이 경우 미리 빌드하지 않아 fallback을 보여준다.
    새롭게 오는 페이지는? 정적 파일로 캐싱된다. (ISR)
   2. fallback false. 빌드 할 때 밖에 캐시를 못함

### 4.3.4 스타일 적용하기
1. document에서 styled-component의 초기화 작업. 날것의 HTML 안보이게.
2. SPEEDY_MODE 속성. CSSOM에 모두 주입하기.

