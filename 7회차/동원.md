# 12. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 12.1 웹사이트와 성능
### 유저가 기대하는 것
1. 웹을 방문한 목적을 쉽게 달성할 것
2. 빠른 시간내에 목적을 달성할 것
3. 웹 내에서 개인정보 보안이 될 것

- 개발자는 모른다. 개발 스펙이 좋고 바쁘니깐 

## 12.2 핵심 웹 지표란?
### 핵심 3가지
1. LCP: 최대 컨텐트 풀 페인트
2. FID: 최초 입력 지연
3. CLS: 누적 레이아웃 이동

### 부가 2가지
1. TTFB: 최초 바이트까지의 시간
2. FCP: 최초 컨텐트 풀 시간

## 12.3 LCP: 최대 컨텐트 풀 페인트
1. 정의: 사용자의 뷰포트 내에서 가장 큰 요소가 렌더링 되는 데 얼마나 걸리는 지 측정한 지표. 
2. 중요한건 뷰포트 내에서. infinity scroll을 예를 들어보자. 그 밑의 뷰포트는 신경안씀
3. 보통 2.5초 안으로 되면 good 이다.
   
### LCP 개선 방안
1. Text 가능하면 써라
2. 이미지 노출 방법
   1. img, picture, video의 post 활용해라. 브라우저의 pre load 기능으로 다른 리로스가 다운되기 전 병력적으로 미리 불러올 수 있다.
   2. svg. pre load 불가능. 다른 리소스가 다운 되고 나서야 불러온다
   3. background image. 제일 느리다. css기 때문에 돔을 모두 그릴 준비가 된 이후에 다운한다.

### 주의사항
1. 이미지 무손실 압축해라
2. loading lazy 주의해라. 캐러셀에선 사용 가능할듯?
3. fade 애니메이션 사용 자제
4. 가능하면 도메인에서 불러와라. 이건 CDN도 마찬가지이려나? 우리 환경에서 사용하기 어렵긴 하겠다. 

## 12.4 FID: 최초 입력 지연
1. 페이지가 빨리 떠도 유저와 상호작용 못하면 소용 없다.
2. 왜 못하나? 싱글 스레드인데, main thread가 일하고 있어서 이벤트 핸들링 할 여유가 없다.
3. 뭐 하느라 바쁜가?
   1. 대규모 렌더링 진행 중
   2. 대규모 JS 분석 중
4. 사용자 입력이란: 클릭, 터치, 타이핑의 경우
5. 정리하자면 FID는 화면이 최초에 그려진 후 사용자가 웹 페지이에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이벤트를 반응할 수 있을 때 까지의 시간을 구한다.
6. 예를 들면, 클릭 한 시점 부터, 실제 클릭 이벤트가 호출되는 시간까지의 시간을 구한다.

### 개선 사항. 메인 스레드에게 여유를 주자
1. long task를 잘게 나눈다. 고려해야할 건, 이 task가 브라우저에서 꼭 해야하는 가, 그렇다면 Suspense, lazy loading, dynamic 등을 이용해 우선순위를 늦추자.
2. 자바스크립트 코드를 최소하하자. 
   1. tree shaking을 하더라도 필요없는 코드들이 있을 수 있다. 하지만 이걸 제거할 수는 없음. 대신 팝업과 같이 나중에 떠도 되는 코드들은 우선순위를 뒤로 미루자
   2. 필요한 폴리필만 사용하자. @babel/preset-env, next의 swr을 사용하자
3. 타사 JS 코드를 지연 수행하자. script의 defer와 async 옵션을 사용할 수 있다.
   1. defer. script를 다른 리소스와 병렬적으로 수행한다. 만약 이 스크립트가 다른 리소스보다 빨리 끝났다 하더라도 실행하지 않고 기다린다.
   2. async. script를 다른 리소스와 병렬적으로 수행한다. 이 스크립트가 다른 리소스보다 먼저 다운로드 됐다면 먼저 실행한다.
   3. 아무것도 안하면, script 태그를 만나는 순간 main 스레드가 이 일을 처리한다.

## 12.5 CLS: 누적 레이아웃 이동
1. 예상치 못한 불필요한 레이아웃 이동으로 유저의 헛클릭질을 막자
2. 보통 useEffect로 state를 이용해 돔을 핸들링 한다면 발생한다.
3. 특징
   1. 뷰 포트 내에서 일어나는 레이아웃 시프트에 한해서 계산한다. 즉, 최초 렌더링을 시작한 위치에서 한다. 이 때문에 디바이스 크기에 따라 수치가 달라진다.
   2. 요소가 추가되더라도 레이아웃 시프트가 일어나지 않으면 상관없다.
   3. 요소가 추가되더라도 다른 요소의 위치를 방해하지 않으면 상관없다.
4. 점수 계산 방법
   1. 영향분율. 비율 이용. height 100, 추가되는 돔의 height 10, 밀리는 거리 10 -> 20 / 100 = 0.2
   2. 거리분율. 거리 이용. height 100, 밀린 거리 10 -> 10 / 100 = 0.1
   3. 총 점수 0.02

### 개선 방안
1. 예상치 못한 것들을 막는다.
   1. useEffect 내에서 돔 핸들링 최소화
   2. useLayoutEffect 고려. 이건 근데 페인트 하는데 성능 안좋음. 고려할 것
   3. 스켈레톤 UI로 height를 가지고 있는다.
   4. 서버사이드 렌더링으로 서버에서 그려서 내려주자.
2. 폰트 로딩 최적화.
   1. FOUT: 사용자 지정 폰트를 다운로드 하기 전 기본 폰트 노출 후, 다운로드 된 폰트 노출.
   2. FOIT: 사용자 지정 폰트를 다운로드 하기 전, 아무 폰트도 노출 안시키고 빈화면. 후에 다운로드 된 폰트 노출
   3. 각 폰트마다 크기가 다르기 때문에 발생할 수 있다.
   4. 해결법은 font-family optional 속성을 쓰자. 0.1초 내에 다운로드가 안되면 멈추고 기본 폰트로 노출 시킨다.
3. 적절한 이미지 크기 설정
   1. 반응형을 위해 height: auto로 지정하는 경우, 최초 로딩 시 width 값을 알 수 없어 height가 늘어났다 줄어든다.
   2. aspect-ratio를 사용한다. width, height값을 지정해 처음부터 비율을 지정한다.
   3. srcset 속성을 사용해 디바이스 환경별 이미지들을 등록해둔다. srcset="mobile.jpg 1000w, desktop.jpg 1300w"

## 12.6 그 외 지표
### TTBT: 최초 바이트를 받는데 까지의 시간
1. 첫 번째 바이트를 수신하는데 걸리는 시간
2. 최초의 응답이 얼마나 빨리 오는가. 
3. 서버 컴포넌트를 사용한다면, 서버에서 페이지를 그려 보내주는데 시간을 짧게 가져야한다.
   
### 개선 사항
1. 페이지 만드는 걸 최소화한다. 
2. api 최적화. 횟수를 줄이고 크기를 줄이자.
3. 리전을 가깝게
4. stream 기법 사용

### FCP: 최초 컨텐트풀 페인트
1. 페이지가 로드된 시점부터 뭐라도 보이기 시작하는 시간. 여기서 뭐라도는 텍스트, 이미지, svg..

### 개선 사항
1. TTBT를 개선한다. 뭐라도 다운이 되야 보일 것
2. 렌더링을 막는 리소스 최소화한다. link나 script. 쓰더라도 비동기적으로 불러올 수 있도록 한다.
3. Above the fold 최적화. 즉, 뷰포트는 빠르게 뜨게 하자. 레이지 로딩 같은 거 하지마라
4. 페이지 리다이렉트 최소화. 리다이렉트 여러번 하면 늦게뜬다.
5. DOM 크기 최소화. 너무 크면 브라우저에서 파싱하는 데 오래 걸린다.

# 13. 웹 페이지의 성능을 측정하는 다양한 방법
## 13.1 애플리케이션에서 확인하기
1. CRA, CNA를 이용해 로그를 찍게한다.
2. next같은 경우, 추가적으로 hydration 하는데 걸리는 시간, 경로 이동 후 렌더링 시작 하는데 걸리는 시간, 경로 이동 후 렌더링 하는데 걸리는 시간을 추가적으로 제공한다.

## 13.2 라이트 하우스
### 성능 체크. LCP, FCP, CLS 외 3가지 더.
1. TTI: time to interaction. 페이지와 사용자가 완전히 상호작용할 수 있을 때 까지 걸리는 시간 ( FCP, hydration 부착 시점.. )
2. Speed Index: 페이지가 로딩될 때 얼마나 빠르게 시각적으로 표시되는 지
3. Total Blocking Time: 메인 스레드 얼마나 블락 당하는 지

### 접근성
1. 장애인, 고령자 사람들이 일반 유저와 동등하게 사용할 수 있는 지
2. 스크린 리더 등

### 권장 사항
1. XSS 공격 막는지, HTTPS 사용, 비밀번호 복붙 가능, 이미지 비율 등..

### SEO
1. meta, title, robots.txt...

### 트리맵
페이지 로딩 중 모든 리소스를 보는. 사이즈 크기 측정

## 13.3 웹 페이지 테스트 ( web page test )

## 13.4 크롬 개발자 도구
### 성능 통계































