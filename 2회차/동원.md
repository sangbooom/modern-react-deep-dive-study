# 03장. 리액트 훅 깊게 살펴보기

## 3.1 리액트 모든 훅 살펴보기

### 3.1.1 useState
1. state가 아닌 let으로 변수 선언 후 이벤트 핸들러로 변수를 업데이트 -> 변하지 않는다. 왜 ?
2. 함수형 컴포넌트는 리렌더링시 함수 자체가 리렌더링 된다. 즉, let으로 할당된 변수로 초기화가 된다. -> 컴포넌트 외부에 let을 선언하면? 변수는 유지 ( 리렌더링 개수 셀 때 )
3. 어떻게 가능한가? 클로저 사용. 내부 구조. 
   -> 단일 state를 구현한 건 봤어도 전체는 처음 본다. 실제는 useReducer. 이해가 된다. 여러 state를 관리하는..
   -> 근데 React에서 내부 구조 못 보게 하는구나. 이건 또 몰랐네. React 톺아보기에 있을 줄 알았음.

#### 게으른 초기화 ( 첨 본듯 아닌 듯 )
1. 초기화가 무거울 때 사용해라.
2. 초기화할 때만 써라. 이후 리렌더링은 무시된다. -> 컨셉은 괜찮은 것 같다. 쓸 일이 있을 듯. useMemo랑 비슷한가? useEffect나 전역변수로 선언하는 것보단 낫겠다. 
3. local, session storage. for loop 때 
4. 초기값에 함수를 넣는다. 
    ```ts
    // 일반적인 방법
    const [state, setState] = useState(..) // 

    // 게으른 초기화
    const [state, setState] = useState(()=> {
        // 복잡한 연산.
        ...

        return foo
    }) // 
    ```


### 3.1.2 useEffect ( useEffect 알아보기 )
useEffect. 컴포넌트 내 값들을 이용해 부수효과(side effect)를 만들어낸다.

#### useEffect란
언제 일어나는 것보단 어떤 상태 값과 함께 실행되는가? 
의존성 배열이 변한 걸 어떻게 알까? 의존성에 있는 값을 보면서 변하면 side effect를 실행한다. -> 이게 끝? 아마도 reconciliation 과정에서 감지를 하지 않을까 싶다. ( 막혀있구나 )

#### 클린업 함수
1. 클린업 함수는 이전 state를 참조해 실행한다. -> 클린업 함수가 먼저 실행되고, 콜백 함수가 실행된다.
2. 이 클린업 함수의 state는 이전 state 값을 참조한다. 정확히는 함수가 정의됐을 때의 state
3. 따라서 첫 렌더링 시 이 클린업 함수가 등록(?)이 된다. -> 다음 렌더링 시 이 함수가 먼저 실행되고 콜백 함수가 실행됨
4. 이벤트 핸들러를 클린업해야 하는 이유. -> 이전 상태를 청소한다.

#### 의존성 배열
빈 배열인 경우, 쓰는 것과 안 쓰는 것의 차이
  1. 쓰는 경우, 렌더링이 된 후 실행. 안 쓰는 경우 첫 렌더링부터
  2. 쓰는 경우 클라이언트 사이드에서 실행.

#### useEffect 구현
1. Object.is를 이용한 얕은 비교

#### 주의할 점
1. 의존성 state를 의도적으로 안 넣기? -> 필요한 경우가 너무 많은데... 메모이제이션을 사용해라? 비용은?
2. useEffect 함수 이름 넣기 -> BO 같은 경우는 괜찮은 것 같기도
3. 거대한 useEffect 피하기 -> 적절히 자르자. 어떤 기준으로잘라야 하나? 목적에 맞게 자를 순 있겠다. 이 목적마저 커지면? 내부에 useCallback, useMemo
4. 불필요한 외부 함수 피하기. 내부에 써라. -> 근데 너무 커지면 어떻게 하나. 이런 경우엔 외부로?
    ```ts
    useEffect(()=>{
        const foo = () => {
            ...
            return bar
        }

        const getBar = foo()
    },[])

    // useCallback 외부
    const foo = useCallback(() => {
        ...
        return bar
    },[])

    useEffect(()=>{
        const getBar = foo()
    },[foo])
    ```

#### useEffect 경쟁상태 ( 첨 봄 )
1. callback 함수의 인자로 async를 사용하지마라. -> useEffect의 순서가 꼬일 수 있음
    ```ts
    useEffect(async () => {
        const response = await fetch('url');
        const result = await response.json();
        setData(result);
    },[])
    ```
2. 내부에서 써라
    ```ts
    useEffect(() => {
        async fetchData = () => {
            const response = await fetch;
            const result = await response.json();
            setData(result);       
        }

    fetchData()

    return () => {
        ...
    }
    },[])
    ``` 

#### 참고
1. [https://react-ko.dev/learn/escape-hatches#you-might-not-need-an-effect](https://react-ko.dev/learn/escape-hatches#you-might-not-need-an-effect)
2. [https://velog.io/@jay/you-might-need-useEffect-diet](https://velog.io/@jay/you-might-need-useEffect-diet)
3. [https://overreacted.io/a-complete-guide-to-useeffect/](https://overreacted.io/a-complete-guide-to-useeffect/)

### 3.1.3 useMemo
1. 큰 비용의 연산 메모한다.
2. 컴포넌트도 메모할 수 있다. -> React.memo와 같은 원리인가? 맞네
    ```ts
    const memoComponent = useMemo(() => <Component value={value}/>, [value])
    ```

### 3.1.4 useCallback
1. 특정 함수를 생성하지 않고 재사용한다. -> 예제의 메모리 주소 바뀌는 것. 메모리 스냅샷 유용하다.
2. useMemo로 구현할 수 있다. 구분은 값을, 함수를 메모하느냐의 차이

### 3.1.5 useRef
1. 내부 current 값에 접근, 변경 가능하다. 값이 변해도 리렌더링 되지 않는다. -> instant tab 생각나네... 비제어 컴포넌트의 원리
2. 그렇다면 컴포넌트 외부에 전역으로 선언하는 거랑 무슨 차이? 단점이 있다.
   1. 메모리에 존재.  
   2. 인스턴스가 여러 개일 때 동일한 값을 본다. -> 컴포넌트가 여러 개임을 말하는 거지? map으로 돌리는
3. 바로 DOM에 접근하기.
4. 이전 상태 값을 저장하기. usePrevious() -> BO: 이전 url을 기억하기 위해 사용
    ```ts
    const usePrevious(value) {
        const ref = useRef();
        useEffect(()=>{
            ref.current = value;
        }, [value])
        return ref.current
    }

    const component = () => {
        const [counter, set] = useState(0);
        const previousCounter = usePrevious(counter);

        ...
    }
    ``` 

5. 구현. useMemo 이용
```ts
const useRef = (initValue) => {
    currentHook = 5 // 이게 뭐지? 파이버에서 작업중인 hook을 나타내는 번호다.
    return useMemo(()=> { current: initValue }, []);
} 
```

### 3.1.6 useContext
1. context API 사용 가능하게 해주는 hook.
2. Provider에 의존한다. 예상치 못한 에러. -> 간단하게 사용하는 이유, store로 쓰지 않는 이유가 아닐까 

### 3.1.7 useReducer
1. 여러 개의 state를 관리한다.
2. flux 패턴. 단방향 바인딩. dispatcher -> action -> set state. 여담으로 redux는 reducer + flux
3. form 관리할 때. ( 상섭님의 useForm )

### 3.1.8 useImperativeHandle
#### forwardRef
1. DOM을 ref로 props로 넘기기
   1. ref를 props로 넘기면 안 된다. ( 예약어이기 때문 )
   2. 예약어를 피해 넘기자. ( 가능 )
2. forwardRef를 쓰는 이유. 일관성 제공

#### useImperativeHandle
1. 부모로부터 받은 forwardRef를 원하는 대로 수정 -> Instant Tab 개선할 수 있겠다...

### 3.1.9 useLayoutEffect
1. useEffect와의 차이
   1. 모든 DOM이 변경된 후에 동기적으로 발생한다. -> Layout Shift가 일어난 후 뭔가를 할 때?
2. 실행 순서
   1. 리액트가 DOM을 업데이트
   2. useLayoutEffect
   3. 브라우저에서 변경 사항 저장
   4. useEffect 
3. 단점은 동기로 작동되기 때문에 순간 일시 정지. 성능 문제가 있을 수 있음.

### 3.1.10 useDebugValue
1. 디버깅 console 찍지 말고 이거 쓰자. 훅 내부에서만 사용 가능

### 3.1.11 훅의 규칙
1. 최상위에서만 호출한다. 반복문, 조건문에서 실행할 수 없다. 동일한 순서 보장 -> 지석님 코멘트. react 19의 use. 반복문, 조건문에서 가능
2. 훅은 리액트 함수 컴포넌트, 커스텀 훅뿐
3. 객체 기반 링크드 리스트. 순서대로 실행된다. 파이버 객체 내 state, effect 값을 저장하고 있기 때문
4. if 문이 앞에 있다면 hook 순서가 깨진다. -> return null을 맨 마지막에 하는 이유. 내부 객체 링크드 리스트엔 아직 hook이 남아있다. 

## 3.2 custom hook과 HOC

### 3.2.1 custom hook
1. 다른 컴포넌트에서 같은 로직을 공유하고자 할 때. -> util 함수와 차이점은 무엇인가.

> abortController

### 3.2.2 HOC
1. 고차 함수의 일종. React.memo: 컴포넌트를 메모

#### React.memo
1. 부모 컴포넌트가 리렌더링 될 때 자식 컴포넌트의 렌더링을 막는다. 이전의 props와 지금의 props를 비교. 같으면 memo 한다.

#### 고차 함수
1. 함수를 인수로 받거나 결과로 반환하는 함수. .map(function())
2. 인가 컴포넌트 구현.

### 3.2.3 뭘 쓸까
1. useState, useEffect로만 이루어진 컴포넌트 -> custom hook
2. 인증, 인가 같은 특정 컴포넌트로 분기를 해야 하는 경우 -> HOC
