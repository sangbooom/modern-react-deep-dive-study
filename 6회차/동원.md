# 11.Next13과 React 18

## 11.1 app 디렉터리의 등장
1. pages 디렉터리의 문제는 레이아웃 개념이 없다는 것. app.tsx에서만 선언할 수 있다. -> app 디렉터리를 통해

### 11.1.1 라우팅
#### 라우팅 정의 방법
1. 폴더 기준으로 정한다. app/a/b -> coloso.co.kr/a/b

#### layout
1. 예약어 파일. 페이지의 기본적인 레이아웃을 구성한다.
2. 꼭 레이아웃이 아니더라도 필요한 기본 정보를 담아도 좋다.
3. 기존의 _document는 root layout이 역할을 담당한다.

#### pages
1. props.
   - params: [...id]와 같은 동적 라우트 파라미터
   - searchParams: URLSearchParams. query string의 key, value 값

#### error
1. 라우팅별 서로 다른 에러 UI 렌더링 가능. 각 단계의 폴더 기준 에러를 처리한다.

#### not-found
#### loading
1. Suspense 기반 로딩 처리

#### route.js
1. BFF 서버

## 11.2 리액트 서버 컴포넌트
### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계
1. 번들 사이즈가 크다. 서버는 괜찮음. 근데 클라는 클라 환경을 많이 받기 때문에.
2. 백엔드 리소스 접근 불가(ㅋㅋ..) 
3. 자동 코드 스플리팅 불가. 이제 자동으로 해준다. 이전에는 Lazy 혹은 라이브러리
4. 워터폴 컴포넌트 렌더링 방식. 최초 컴포넌트가 되어야 하위 컴포넌트. 서버 요청 지연
5. 추상화 비용이 증가한다. 복잡한 작업을 서버에서 위임하자. 클라이언트 로직이 간결해진다.

정리하자면 클라이언트 중심이기 때문에 한계가 발생한다. 

### 11.2.2 서버 컴포넌트란?
1. 서버 컴포넌트는 서버 작업을, 클라 컴포넌트는 클라이언트 작업을 한다.
2. 클라는 서버 컴포넌트를 import할 수 없다. children으로 가능
3. 서버 컴포넌트의 특징
   - 딱 한 번 실행. 상태 가질 수 없다.
   - 생명주기 사용 불가, state, effect 사용 불가
   - 서버용 훅은 사용 가능
   - 브라우저 기능 사용 불가
   - 컴포넌트 비동기 작업 가능
   - 다른 컴포넌트 렌더링 가능
4. 클라 컴포넌트 특징
   - 자식으로 서버 컴포넌트 가능. 왜? 서버에서 트리를 이미 만들었다. 클라는 서버에서 만들어진 트리를 삽입해서 보여주기만 하기 때문. ( 시원하게 설명 부탁 )
5. 공용 컴포넌트 ( 첨본다. )

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이
#### SSR
1. HTML 렌더링을 서버에서 수행, 클라이언트에 내려준다.
2. 클라이언트에서 하이드레이션을 거쳐 결과물 확인 후 이벤트 추가
3. 목적은 초기 인터렉션은 불가 하지만, HTML을 빠르게 보여준다. 하지만 자바스크립트 코드를 다운로드, 파싱, 실행하는 데 비용이 든다.

#### RSC + SSR
1. 동시에 하자. 빠르게 RSC하고 SSR도 하자. 

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?
1. 서버가 렌더링 요청. 루트는 항상 서버 컴포넌트다.
2. 컴포넌트들을 JSON 직렬화 한다.
3. 서버에서 렌더링할 수 있는 것들을 직렬화 하고, 클라이언트 컴포넌트는 플레이스홀더 형식으로 비워둔다.
4. 브라우저는 이 결과물을 받아 다시 역직렬화 후 다음 렌더링 수행
   - M: 클라이언트. chunk를 이용해 어디에 있는 지 참조
   - S: suspense
   - J: 서버 컴포넌트 @1, @2를 이용해 M1, M2자리 명시
5. 브라우저가 서버로 스트리밍으로 이 JSON을 받았다면 다시 파싱해 트리를 재구성해 컴포넌트를 만든다.
6. M이면 클라이언트에서 렌더링 진행, J이면 있는 그대로 렌더링한다.

#### 특별한점.
1. 스트리밍 형태로 보낸다. 클라이언트는 줄 단위로 JSON을 읽고 컴포넌트를 렌더링해 빠르게 보여줄 수 있다.
2. 하나의 번들러 작업에 포함되어 있지 않고 각 컴포넌트별로 번들링. 지연 받기 수월해진다.
3. HTML이 아닌 JSON 형태로 받는다. 서버와 클라를 조화롭게 받는게 목표다. JSON을 받아 최대한 빠르게 컴포넌트 트리를 구성한다.

## 11.3 Next.js에서의 리액트 서버 컴포넌트
### 11.3.1 새로운 fetch 도입과 gssp, gsp, gip의 삭제
1. SSR과 SSG는 fetch를 이용해 한다. ( 옛날 자료? )

### 11.3.2 정적 렌더링과 동적 렌더링
1. 정적 렌더링의 경우 빌드 타임에 렌더링을 해놓고 캐싱해 재사용한다.
2. 동적 렌더링의 경우 매번 호출
3. 정적으로 만들기. generateStaticParams

### 11.3.3 캐시와 mutating, revalidate
1. router.refresh: 캐시 전체 무효화

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기
1. Suspense 사용

## 11.4 터포백 등장
.

## 11.5 서버 액션
1. 서버에 직접 접근해 데이터 요청 수행
2. RSC완 다르게 특정 함수 실행 그 자체만을 서버에서 수행한다.

### 11.5.1 form의 action
1. post 시, post 요청이 아닌 별도의 ACTION_ID로 변한다.
2. 현재 라우트 주소와 ACTION_ID를 보내고 이것을 바탕으로 서버에서 직접 실행한다.
3. use server로 코드 블럭을 미리 분리시키고 서버로 옮겨 번들링 결과에 포함되지 않도록 한다.
4. @vercel/kv. redis 이용. 잠깐 이거 access_token 가능한가? 적당히 할까? 쿠키를 썼음 좋겠다.
