# 2.1. JSX란?
1. 리액트에 종속 X
2. 독자적으로 실행 불가. 트랜스파일러를 거쳐 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환한다.
3. XML 처럼 
    ```ts
    <TextInput>
      ....
    </TextInput>
    ```

## 2.1.1 JSX의 정의
### JSXElement: JSX의 형태
1. OpeningEle: `<p></p>`
2. ClosingEle: `<br />`
3. SelfClosingEle: `<div require />`
4. Fragment: `<></>`

5. MemberExpression: `<Layout.Header> ... </Layout.Header>`

### JSXAttribute: JSXElement에 부여할 수 있는 속성
1. SpreadAttributes `<div {...{ foo: bar } }>..</div> `
2. Attribute: `<img alt="text"/>`

### JSXChildren
1. children

### JSXStrings
1. `<div>text</div>`

## 2.1.3 트랜스파일링 결과
순서대로 JSX Element, Attribute, child가 변환
RSC payload랑 유사한 형태?

```ts
const xx = (
    <div require={true}>
        <p>child</p>
    </div>
    )

var xx = React.createElement(
    'div',
    {
        require: true,
    },
    React.createElement(
        'p',
        null,
        'child'
    )
)
```

# 2.2 가상 DOM, 파이버
코드로 읽는 순서

```html
#text {
    ...
}

<html>
    <head>
        <link stylesheet />
    </head>
    <body>
        <div style="width: 100%">
            <p id="text" style="widthL 50%">hello</p>
        </div>
    </body>
</html>

```

## 2.2.2 가상 DOM 탄생 배경
가상 DOM 까지의 탄생 배경. ( 여기서 이전은 SPA 전 얘기가 아니네? SPA의 가상 DOM 이전의 얘기. )
1. 페인팅X, 레이아웃과 리페인팅이 일어나는 경우. 변경이 일어나는 DOM을 모두 제거하고 다시 생성하는 과정을 거친다.
2. 부담이다. -> 가상 DOM
3. 브라우저의 DOM이 아닌 리액트 DOM을 메모리에 저장한다. ( 렌더링 과정 중복 최소화 )
4. 변경될 DOM이 준비되면 브라우저 DOM에 반영한다.

> 브라우저 DOM을 끼우는 것보다 빠른 건 아니다. 하지만 충분히 빠름
> 속도는 어느정도 보장, 브라우저와 개발자의 부담을 던다?

## 2.2.3 리액트 파이버: 리액트에서 렌더링 최적화
1. 자바스크립트 객체다
2. 파이버 재조정자(fiber reconciler): 실제 DOM, 가상 DOM 변경점 비교, 변경이 있으면 반영
3. 동시성의 일을 한다.
   1. 작업 쪼개고 우선순위 매기기
   2. 작업 일시 중지, 다시 시작하기
   3. 이전 작업 재사용, 폐기
4. 비동기적으로 일한다. ( 동시성 ) ref: [https://jgjgill-blog.netlify.app/post/learn-about-react-concurrent/](https://jgjgill-blog.netlify.app/post/learn-about-react-concurrent/)
5. 파이버 두 가지 작업
   1. 렌더 단계: 비동기 작업. 우선순위..
   2. 커밋 단계: DOM에 반영
6. 내부 구조: memoizedState: 모든 hook 목록. 커스텀 훅도? 만약 그렇다면 util보다 나은가
7. state가 변경되거나, DOM이 변경되거나 작동
8. 스케줄링 기능. 애니메이션 먼저 한다든지..

### 리액트 파이버 트리
1. 현재 파이버 트리, WIP 파이버 트리. 파이버 작업이 끝나면 WIP를 현재 파이버 트리로 교체한다.
2. 위 작업은 커밋 단계에서 실행함
3. 업데이트할 게 생기면, 업데이트할 WIP 트리를 빌드함.
4. 빌드가 끝나면 이걸 현재 파이버 트리로 교체

### 파이버 작업 순서
1. openingEle: beginWork
2. closingEle: completeWork
3. 형제 있으면 형제 openingEle: beginWork
4. 마지막 return시 commitWork


### 파이버와 가상 DOM
1. 가상 DOM을 만들 때 파이버 알고리즘이 사용됨 ( 현재 파이버와 WIP 파이버 비교 과정, 비동기, 우선순위 작업 등.. )
2. 위 작업을 메모리에서 먼저 실행 후, 실제 브라우저 DOM에 적용한다.


# 2.4 렌더링은 어떻게 일어나는가
1. 브라우저 렌더링: html, css 기반으로 웹페이지 만드는 것
2. 리액트 렌더링: 브라우저가 렌더링에 필요한 DOM을 만드는 과정

## 2.4.1 리액트 렌더링이란
리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 가지고 있는 props와 state를 기반으로 UI를 구성하고, 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 과정
props, state가 없다면 단순 JSX를 렌더링

## 2.4.2 리액트 렌더링이 일어나는 이유
### 언제?
1. 최초 렌더링
2. 리렌더링
   1. setState()
   2. useReducer의 Dispatch
   3. 컴포넌트의 key, props 

### key에 관해서
1. 형제 요소를 구분. 언제? current, WIP 파이버에서 업데이트할 DOM을 찾을 때
2. key가 없다면? index로 구분한다.
3. 다음 예제가  <Child key={index} />. 동작이 같은 거지?
4. <Child index=random /> key index를 넣을 수도 있다? 근데 memo 해도 소용없다. 여기서 fiber의 key, memo의 연관?
5. <Child key=random /> 이 경우 강제로 리렌더링을 일으킬 수 있다.

### 상태 관리들은?
내부에서 useState 등 리렌더링을 일으키고 있다.


## 2.4.3 리액트의 렌더링 프로세스
1. 업데이트가 필요하다면, 함수 컴포넌트 자체를 return 후 저장한다.
2. 함수 컴포넌트 -> JSX -> 자바스크립트 객체
   ```ts
   function xx() {
    TestComponent,  // type
    { foo: 'bar'},  // props
    'TETX'          // key
   }

   { type: TestComponent, props: { foo: 'bar'}, children: '안녕하세요.'}
   ```
3. 계산 후 적용. ( 파이버의 재조정 )

## 2.4.4 렌더와 커밋
### 렌더
1. 컴포넌트를 레더링하고, 변경 사항을 계산하는 모든 작업
2. 컴포넌트 실행 ( 자바스크립트 객체로 ) + 파이버 DOM 비교
3. key, props, key 세 가지 비교. 이게 달라지면 변경이 필요한 컴포넌트로 체크

### 커밋
1. 변경 사항을 업데이트 ( 아마 WIP 파이버 DOM에 )
2. 리액트 내부 참조 업데이트 ( current -> WIP 파이버로 )
3. useLayoutEffect 훅
4. 커밋까지 갈 필요가 없다면, 커밋은 생략될 수 있다. 렌더 단계에서 변경 사항을 감지 못하면 커밋이 생략된다. ( 이 경우 어떤 경우 ? )
    1. React memo
    2. pure component, function component의 얕은 비교
    3. 조건부 렌더링의 false
    4. 빈 이벤트 핸들러

### 리액트의 동시성
1. 비동기 렌더링을 하자
2. 우선순위대로 보여주자
    ```ts
    const [first, setFirst] = useState(0)
    const [second, setSecond] = useState(0)
    const [third, setThird] = useState(0)

    const deferredSecond = useDeferredValue(second)

    // 전부 +1 해주는 버튼을 클릭 했을 때,

    console.log('first', first)
    console.log('second', second)
    console.log('third', third)
    console.log('deferredSecond', deferredSecond)

    // first batch
    first: 1 
    second: 1
    third: 1
    deferredSecond: 0 

    // second batch
    first: 1 
    second: 1
    third: 1
    deferredSecond: 1
    ```

# 2.5 메모할까 말까
1. 잘못된 memo로 지불하는 비용: props에 대한 얕은 비교가 발생하면서 지불하는 비용
   중복해서 memo 하고 있다는 말. 그럼 깊은 비교 땐 하는 게 좋다?
2. console.log 찍히는 로그. 왜? 커스텀 훅 때문에 혼동이 된다. 편하게 생각
   리렌더링 -> 객체의 참조가 바뀐다. ( 이건 파이버 DOM 의 참조를 말하는 것인가? )
   -> useMath 호출 -> value return -> dependency
   value를 useMemo로 감싸자.

``



