# 5장. 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?
1. 상태: 어떤 의미를 지닌 값, 애플리케이션 시나리오에 따라 지속적으로 변할 수 있는 값.
    - UI: 다크 모드..
    - url: 브라우저의 상태 값.  query params
    - form
    - 서버 응답 값
2. tearing이 뭐야? 틀어지는 거. 예를 들어 그래픽카드와 모니터의 주사율 차이로 인한 틀어짐.

### 5.1.1 리액트 상태 관리의 역사
#### FLUX 패턴
1. 단방향 바인딩을 한다. 액션 -> 디스패처 -> 모델 -> 뷰
   1. 액션: 작업을 처리할 액션과 액션 발생 시 포함시킬 데이터
   2. 디스패처: 액션을 스토어에 보내는 역할. 콜백 함수의 형태
   3. 스토어: 액션의 타입에 따라 변경하는지 결정
   4. 뷰: 스토어의 데이터를 가져와 화면에 보여주는

#### 리덕스의 등장
1. Elm: 웹페이지를 선언적으로 작성하기 위한 언어, Elm 아키텍처: 모델, 뷰, 업데이트.
2. 리덕스 동작 방식
   1. 하나의 상태 객체를 스토어에 저장
   2. 디스패치를 이용해 업데이트
   3. reducer 함수로 발생. store 복사본을 반환한 후 새롭게 만들어진 객체를 전파한다.
   4. props drilling 문제 해소. 하지만 코드 양이 너무 많아진다.

#### Context API, useContext
1. Context이전 -> getChildContext: 단점. 상위 컴포넌트가 렌더링 될 때 리렌더링이 일어나고 컴포넌트 간 결합도가 높아진다.

#### 훅의 탄생, React Query와 SWR
1. fetch. API 호출에 대한 상태를 관리. HTTP 요청에 특화된 상태 관리 라이브러리다.

## 5.2 리액트 훅으로 시작하는 상태 관리
### 5.2.1 useState, useReducer
1. customHook으로 useState, useReducer를 관리할 수 있다.
2. 동일한 계층에서, 이 hook의 state를 동일하게 바라보려면 어떻게 해야 할까?
3. Parent 컴포넌트에서 선언 후, prop로 넘겨준다. 하지만 drilling

### 5.2.2 지역 상태의 한계를 벗어나 보자: useState의 상태를 바깥으로 분리하기
1. 별도의 파일을 생성해 전역 객체를 만들어보자. 문제가 뭘까? 리렌더링이 되지 않는다. -> 리액트의 렌더링 방식
2. 함수 컴포넌트의 리렌더링 조건이 없다. state, props 변화 등..
3. 그럼 이 파일의 객체를 useState로 써보자. 비효율적이다.
   1. set 함수를 setState 내부에서도 써야 한다.
   2. state가 공유하지만 동시에 렌더링 되지 않는다. trigger 한 컴포넌트만 렌더링이 된다.
4. 결론은 다음과 같다.
   1. 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트에서 같이 쓸 수 있어야 한다.
   2. 상태의 변화를 알아채고 리렌더링이 일어나 최신 값으로 렌더링 해야 한다. 이 상태를 참조하는 모든 컴포넌트에서 똑같이
   3. 객체의 경우 키가 변경됐다고 리렌더링이 일어나선 안된다. 

#### createStore, useStore 훅
1. store: 사용자 지정 store. 원하는 객체 주입
2. get: [state, useState]의 역할.
3. set: subScribe, clean up subScribe
4. 이 방식의 문제점은 객체의 경우도 값이 변한다면 리렌더링 된다.

#### selector 추가
1. store가 변경되더라도 selector가 변경되지 않으면 리렌더링이 일어나지 않는다.
2. 이제 store의 값이 아닌 selector를 이용해 제어한다.

#### useSubscribe와의 차이
1. selector와 subscribe에 대한 비교. 불필요한 리렌더링을 막는다. 

### 5.2.3 useState와 Context를 동시에 사용해 보기
1. 단일 스토어의 문제점은 전역 변수처럼 작동. 여러 개의 스토어를 가질 수 없다.
2. 스코프마다 스토어의 구조는 동일하되, 여러 개의 데이터를 공유해 사용하고 싶다면?
   1. createStore을 이용해 여러 store를 만든다. -> 번거롭다. 핸들링 하는 useStore도 개수만큼 만들어야 한다.
   2. Context를 이용해 주입된 스토어에만 접근한다. (Context 특)``
   3. 스토어 대신 Context.Provider의 값을 찾는다.

### 5.2.4 상태 관리 라이브러 Recoil, Jotai, Zustand 살펴보기
1. Recoil, Jotai: 훅 기반, 작은 상태 핸들링, Zustand: 클로저 기반 단일 스토어

### Recoil
1. RecoilRoot: recoil store 생성. store에 접근, 상태 값 변경. 하위 컴포넌트에게 notify
2. atom: recoil 최소 상태 단위. key, default
3. useRecoilValue: get atom. 렌더링이 필요하지 않는 값을 ref에 매번 저장, recoilValue가 변경됐을 때 forceUpdate
4. useRecoilState: get, set atom
5. selector: 비동기 api 작업

### Jotai
1. atom과 비슷. 최적화를 하지 않아도 리렌더링이 발생하지 않는다. (?)
2. atom에 key는 없다. config: { init, read, write }
3. useAtomValue: useReducer: {version, valueFromReducer, atomFromReducer}
    1. 차례로 store 버전, get, atom. 
4. useAtom: `[useAtom, useSetAtom]`

### Zustand
1. redux 영감. 단일 store 제공
2. state, setState. -> partial, replace로 나뉨
3. partial은 일부만 바꾸고 싶을때, replace는 완전히 새로운 값으로 바꾸고 싶을 때
4. getState: 클로저 최신 값, subscribe: listener 등록, destroy: 초기화

